# -*- coding: utf-8 -*-
"""backend_models

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BgFPXA6amlG56_HtTR7FmCjN3QmfHazs
"""

from cmdstanpy import install_cmdstan, CmdStanModel
install_cmdstan()   # <— esto descargará e instalará CmdStan en Colab

import pandas as pd
import numpy as np
import statsmodels.api as sm
from cmdstanpy import CmdStanModel
import os

# --- 0. Escribir los .stan ---
# 1) Poisson
poisson_code = r"""
data {
  int<lower=0> N;
  int<lower=1> K;
  matrix[N,K] X;
  array[N] int<lower=0> Y;
}
parameters {
  vector[K] beta;
}
model {
  beta ~ normal(0, 1e5);
  for (i in 1:N)
    Y[i] ~ poisson(exp(X[i] * beta));
}
generated quantities {
  vector[N] mu;
  for (i in 1:N) mu[i] = exp(X[i] * beta);
}
"""
if not os.path.exists('pois_model.stan'):
    with open('pois_model.stan','w') as f:
        f.write(poisson_code)

# 2) Negative Binomial NB2
nb_code = r"""
data {
  int<lower=0> N;
  int<lower=1> K;
  matrix[N,K] X;
  array[N] int<lower=0> Y;
}
parameters {
  vector[K] beta;
  real<lower=0> theta;
}
model {
  beta  ~ normal(0, 1e5);
  theta ~ gamma(1e-3, 1e-3);
  for (i in 1:N) {
    real mu = exp(X[i] * beta);
    Y[i] ~ neg_binomial_2(mu, theta);
  }
}
generated quantities {
  vector[N] mu;
  real Dispersion;
  vector[N] PRes;
  for (i in 1:N) {
    mu[i]   = exp(X[i] * beta);
    PRes[i] = square((Y[i] - mu[i]) / sqrt(mu[i] + mu[i]^2 / theta));
  }
  Dispersion = sum(PRes) / (N - (K + 1));
}
"""
if not os.path.exists('nb_model.stan'):
    with open('nb_model.stan','w') as f:
        f.write(nb_code)

# 3) NB-P con exponente Q
nbp_code = r"""
data {
  int<lower=0> N;
  int<lower=1> K;
  matrix[N,K] X;
  array[N] int<lower=0> Y;
}
parameters {
  vector[K] beta;
  real<lower=0> theta;
  real<lower=0,upper=3> Q;
}
model {
  beta  ~ normal(0, 1e5);
  theta ~ gamma(1e-3, 1e-3);
  Q     ~ uniform(0, 3);
  for (i in 1:N) {
    real mu      = exp(X[i] * beta);
    real phi_eff = theta * pow(mu, Q);
    Y[i]         ~ neg_binomial_2(mu, phi_eff);
  }
}
generated quantities {
  vector[N] expY;
  vector[N] varY;
  vector[N] PRes;
  real dispersion;
  for (i in 1:N) {
    real mu       = exp(X[i] * beta);
    expY[i]       = mu;
    varY[i]       = mu + pow(mu, 2 - Q) / theta;
    PRes[i]       = square((Y[i] - mu) / sqrt(varY[i]));
  }
  dispersion = sum(PRes) / (N - (K + 2));
}
"""
if not os.path.exists('nbp_model.stan'):
    with open('nbp_model.stan','w') as f:
        f.write(nbp_code)

# --- 1. Lectura de datos y stan_data ---
df = pd.read_csv('GCs.csv')  # o ruta correcta
X = sm.add_constant(df['MV_T'].values)
Y = df['N_GC'].astype(int).values
N, K = X.shape

stan_data = {'N': N, 'K': K, 'X': X, 'Y': Y}
stan_data_poisson = stan_data.copy()
stan_data_nb      = stan_data.copy()
stan_data_nbp     = stan_data.copy()

# --- 2. Compilación ---
pois_model = CmdStanModel(stan_file='pois_model.stan')
nb_model   = CmdStanModel(stan_file='nb_model.stan')
nbp_model  = CmdStanModel(stan_file='nbp_model.stan')

# --- 3. Funciones ---
def run_poisson(chains=3, warmup=1000, sample=2000, thin=1):
    return pois_model.sample(
        data=stan_data_poisson,
        chains=chains,
        iter_warmup=warmup,
        iter_sampling=sample,
        thin=thin
    )

def run_nb(chains=3, warmup=3500, sample=3500, thin=1):
    return nb_model.sample(
        data=stan_data_nb,
        chains=chains,
        iter_warmup=warmup,
        iter_sampling=sample,
        thin=thin
    )

def run_nbp(chains=3, warmup=5000, sample=20000, thin=1):
    return nbp_model.sample(
        data=stan_data_nbp,
        chains=chains,
        iter_warmup=warmup,
        iter_sampling=sample,
        thin=thin
    )